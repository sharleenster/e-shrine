<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>E-Shrine ‚Äì Tiered Candles</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: #eee;
    }

    #stage {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    .candle-wrap {
      position: absolute;
      display: inline-block;
      pointer-events: auto;
    }

    .candle {
      width: 100%;
      cursor: pointer;
      user-select: none;
      transition: transform .2s ease;
      will-change: transform, filter, opacity;
      display: block;
    }
    .candle:hover { transform: scale(1.03); }

    /* Whisper text ‚Äì always above candles */
    .msg {
      position: absolute;
      left: 50%;
      bottom: calc(100% - 8px);
      transform: translateX(-50%);
      font-size: 13px;
      line-height: 1.2;
      text-align: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity .35s ease;
      color: #cac6c6 !important;  /* light grey whisper */
      white-space: nowrap;
      max-width: 320px;
      overflow: hidden;
      text-overflow: ellipsis;
      text-shadow: 0 0 4px rgba(0,0,0,0.85);
      z-index: 1000;
    }
    .msg.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    .msg.smoke-out {
      animation: msgSmoke 1.8s ease-out forwards;
    }

    @keyframes msgSmoke {
      0% {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
      100% {
        opacity: 0;
        transform: translateX(-50%) translateY(-22px);
      }
    }

    /* Whisper trace (soft, ephemeral gesture) */
    .trace {
      position: absolute;
      left: 50%;
      top: -16px;
      transform: translateX(-50%);
      height: 8px;
      width: 70px;
      border-radius: 999px;
      background: rgba(255,255,255,0.55);
      filter: blur(6px);
      opacity: 0.75;
      pointer-events: none;
      transition:
        opacity 20s ease-out,
        filter 20s ease-out,
        transform 20s ease-out;
      z-index: 1200; /* above whisper text */
    }

    .trace.fade {
      opacity: 0;
      filter: blur(14px);
      transform: translateX(-50%) translateY(-10px);
    }

    /* Bottom input bar ‚Äì matches index.html, rectangular with subtle rounding */
    #bottom-bar {
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      width: min(70vw, 640px);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 10px;
      background: rgba(0,0,0,0.8);
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.35);
      box-shadow: 0 8px 25px rgba(0,0,0,0.7);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      z-index: 200;
    }

    #wish-input {
      flex: 1;
      border: none;
      outline: none;
      background: transparent;
      color: #f5f5f5;
      font-size: 14px;
      padding: 4px 2px;
    }

    /* Instructional feel: grey + italic */
    #wish-input::placeholder {
      color: #cac6c6;
      font-style: italic;
    }

    #wish-input:disabled {
      color: rgba(200,200,200,0.4);
    }

    /* Back arrow inside bar (right) ‚Äì no circle, matches index arrow */
    #back-arrow {
      font-size: 18px;
      color: rgba(255,255,255,0.7);
      cursor: pointer;
      padding: 0 6px;
      box-shadow: 0 0 0 rgba(255,255,255,0);
      transition:
        color 0.2s ease,
        background 0.2s ease,
        box-shadow 0.25s ease,
        transform 0.2s ease;
      margin-left: 8px;
      flex-shrink: 0;
    }

    #back-arrow:hover {
      color: #ffffff;
      box-shadow: 0 0 14px rgba(255,255,255,0.45); /* soft glow */
      transform: translateY(-1px);
    }
  </style>
</head>
<body>
  <div id="stage"></div>

  <!-- Input bar with back arrow inside (right) -->
  <div id="bottom-bar">
    <input
      id="wish-input"
      type="text"
      maxlength="80"
      placeholder="Select a candle to light it and leave a whisper."
      disabled
    />
    <div id="back-arrow">‚Üê</div>
  </div>

  <script>
    // ------------ layout & timing knobs ------------
    const PER_ROW_COUNTS = [12, 12, 12];
    const ROWS           = PER_ROW_COUNTS.length;

    // Each candle in the shrine gets a stable index (0,1,2,3...)
    let nextCandleIndex = 0;

    const EDGE_X        = 80;
    const EDGE_Y_TOP    = 60;
    const BOTTOM_GUTTER = 200;

    const JITTER_X_PCT  = 0.03;
    const JITTER_Y_PX   = 4;

    // Bigger candles overall
    const MIN_W         = 100;  // far row
    const MAX_W         = 150;  // near row

    const AUTO_OUT_MS       = 60000;
    const LIGHT_MS          = 3000;
    const OUT_MS            = 2500;
    const MESSAGE_MAX_CHARS = 80;
    const MESSAGE_VIS_MS    = 20000;

    const ENTRY_PAGE = 'index.html';

    const stage     = document.getElementById('stage');
    const wishInput = document.getElementById('wish-input');
    const backArrow = document.getElementById('back-arrow');

    const stateMap  = new WeakMap();
    const autoMap   = new WeakMap();
    const msgMap    = new WeakMap();

    // NEW: keep a reference to every candle wrapper by index
    const allCandles = [];

    // -----------------------------------------------------------
// Visual: render a soft trace near the candle for a whisper row
// -----------------------------------------------------------
window.renderWhisperTraceNearCandle = function (row) {
  if (!row || !row.candle_id) return;

  // candle_id looks like "candle_01"
  const parts = String(row.candle_id).split('_');
  const idx = parseInt(parts[1], 10);
  if (Number.isNaN(idx)) return;

  const wrap = allCandles[idx];
  if (!wrap) return;

  const el = document.createElement('div');
  el.className = 'trace';

  // optional: vary width based on trace_public length
  const t = row.trace_public;
  if (typeof t === 'string' && t.length) {
    el.style.width = `${Math.min(140, 50 + t.length * 10)}px`;
  }

  wrap.appendChild(el);

  // fade then remove
  setTimeout(() => el.classList.add('fade'), 40);
  setTimeout(() => el.remove(), 20500);
};


    let activeCandle = null;

    function clearAutoTimer(node) {
      const id = autoMap.get(node);
      if (id) { clearTimeout(id); autoMap.delete(node); }
    }

    function setAutoTimer(node) {
      clearAutoTimer(node);
      const id = setTimeout(() => extinguish(node), AUTO_OUT_MS);
      autoMap.set(node, id);
    }

    function clearMessage(node) {
      const { msgEl } = node.__ui || {};
      if (!msgEl) return;
      const prior = msgMap.get(node);
      if (prior) { clearTimeout(prior); msgMap.delete(node); }
      msgEl.classList.remove('show', 'smoke-out');
      msgEl.textContent = '';
    }

    function showMessage(node, text) {
      const { msgEl } = node.__ui;
      if (!msgEl) return;

      const trimmed = (text || '').trim().slice(0, MESSAGE_MAX_CHARS);
      if (!trimmed) return;

      clearMessage(node);

      msgEl.textContent = trimmed;
      msgEl.classList.add('show');

      const stayId = setTimeout(() => {
        msgEl.classList.add('smoke-out');

        const ANIM_MS = 1800;
        const finishId = setTimeout(() => {
          msgEl.classList.remove('show', 'smoke-out');
          msgEl.textContent = '';
          msgMap.delete(node);
        }, ANIM_MS);

        msgMap.set(node, finishId);
      }, MESSAGE_VIS_MS);

      msgMap.set(node, stayId);
    }

    function resetInputToIdle() {
      wishInput.value = '';
      wishInput.disabled = true;
      wishInput.placeholder = 'Select a candle to light it and leave a whisper.';
    }

    function enableInputForActive() {
      wishInput.disabled = false;
      wishInput.value = '';
      wishInput.placeholder = 'Type your whisper and press Enter to send.';
      wishInput.focus();
    }

    function extinguish(node) {
      const { imgEl } = node.__ui;
      const s = stateMap.get(node);
      if (s !== 'on') return;

      clearAutoTimer(node);
      clearMessage(node);

      imgEl.src = 'assets/images/candle_out.gif';
      stateMap.set(node, 'extinguishing');

      resetInputToIdle();

      setTimeout(() => {
        imgEl.src = 'assets/images/static_candle.png';
        stateMap.set(node, 'off');
        if (activeCandle === node) activeCandle = null;
      }, OUT_MS);
    }

    function createCandle(x, y, widthPx, depthT, isBottomRow, index) {
      const wrap = document.createElement('div');
      wrap.className = 'candle-wrap';
      wrap.style.left  = `${x}px`;
      wrap.style.top   = `${y}px`;
      wrap.style.width = `${widthPx}px`;

      // store a stable index on this candle wrapper
      wrap.dataset.candleIndex = String(index);

      // NEW: remember this wrapper in our array
      allCandles[index] = wrap;

      stage.appendChild(wrap);

      const img = document.createElement('img');
      img.className = 'candle';
      img.src = 'assets/images/static_candle.png';
      img.alt = 'Candle';
      wrap.appendChild(img);

      const msg = document.createElement('div');
      msg.className = 'msg';
      wrap.appendChild(msg);

      wrap.__ui = { imgEl: img, msgEl: msg };
      stateMap.set(wrap, 'off');

      img.addEventListener('click', () => {
        const s   = stateMap.get(wrap);
        const idx = wrap.dataset.candleIndex;
        console.log('Clicked candle index:', idx);

        // only one active candle at a time
        if (activeCandle && activeCandle !== wrap) return;

        // OFF ‚Üí LIGHTING
        if (s === 'off') {
          activeCandle = wrap;
          clearMessage(wrap);
          resetInputToIdle();

          // Write this candle's state to Supabase (if available)
          if (typeof writeCandleState === 'function' && idx != null) {
            writeCandleState(parseInt(idx, 10));
          }

          img.src = 'assets/images/candle_light.gif';
          stateMap.set(wrap, 'lighting');
          wishInput.disabled = true;

          setTimeout(() => {
            img.src = 'assets/images/candle_loop.gif';
            stateMap.set(wrap, 'on');
            setAutoTimer(wrap);
            enableInputForActive();
          }, LIGHT_MS);

        // ON ‚Üí EXTINGUISHING (manual click)
        } else if (s === 'on') {
          stateMap.set(wrap, 'extinguishing');
          img.src = 'assets/images/candle_out.gif';
          clearAutoTimer(wrap);
          wishInput.disabled = true;

          setTimeout(() => {
            img.src = 'assets/images/static_candle.png';
            stateMap.set(wrap, 'off');
            if (activeCandle === wrap) activeCandle = null;
            resetInputToIdle();
          }, OUT_MS);
        }
      });
    }

    function layoutRowsDepth() {
      stage.innerHTML = '';
      activeCandle = null;
      resetInputToIdle();
      nextCandleIndex = 0;

      const W = stage.clientWidth;
      const H = stage.clientHeight;

      const usableH = Math.max(240, H - EDGE_Y_TOP - BOTTOM_GUTTER);
      const usableW = Math.max(300, W - EDGE_X * 2);

      const rowPositionsT = [0.2, 0.52, 0.84];

      for (let r = 0; r < ROWS; r++) {
        const count = PER_ROW_COUNTS[r];
        if (!count) continue;

        const depthT = (r + 0.6) / ROWS;
        const rowYCenter = EDGE_Y_TOP + rowPositionsT[r] * usableH;
        const slotW = usableW / count;

        for (let c = 0; c < count; c++) {
          const baseCenterX = EDGE_X + c * slotW + slotW / 2;

          const jitterX = (Math.random() * 2 - 1) * slotW * JITTER_X_PCT;
          const jitterY = (Math.random() * 2 - 1) * JITTER_Y_PX;

          const baseW = MIN_W + depthT * (MAX_W - MIN_W);
          const rowScale = (r === ROWS - 1) ? 1.25 : 1.0;
          const w = Math.min(baseW * rowScale, slotW * 0.9);

          const x = baseCenterX - w / 2 + jitterX;
          const y = rowYCenter - (w * 1.1) / 2 + jitterY;

          createCandle(
            x,
            y,
            w,
            depthT,
            r === ROWS - 1,
            nextCandleIndex++
          );
        }
      }
    }

    layoutRowsDepth();

    window.addEventListener('resize', () => {
      layoutRowsDepth();
    });

    // Enter to send wish
    wishInput.addEventListener('keydown', (e) => {
      if (e.key !== 'Enter') return;

      const text = (wishInput.value || '').trim();
      if (!text) return;
      if (!activeCandle) return;

      const s = stateMap.get(activeCandle);
      if (s !== 'on') return;

      showMessage(activeCandle, text);
      const idx = parseInt(activeCandle.dataset.candleIndex, 10);
if (typeof window.writeWhisper === 'function' && !Number.isNaN(idx)) {
  window.writeWhisper(idx, text);
}
      wishInput.value = '';
    });

    // Back arrow ‚Üí entry page
    if (backArrow) {
      backArrow.addEventListener('click', () => {
        document.body.style.transition = 'opacity 0.9s ease';
        document.body.style.opacity = '0';
        setTimeout(() => {
          window.location.href = ENTRY_PAGE;
        }, 900);
      });
    }

    // -------------------------------------------------
    // Backend ‚Üí UI helper: apply candles from Supabase
    // (used on initial load + realtime events)
    // -------------------------------------------------
    window.applyBackendLitCandles = function (rows) {
      if (!rows || !rows.length) return;

      rows.forEach((row) => {
        const idx = row.candle_index;
        const wrap = allCandles[idx];
        if (!wrap) return;

        const currentState = stateMap.get(wrap);
        // Don't override a candle in use locally
        if (currentState && currentState !== 'off') return;

        const ui = wrap.__ui;
        if (!ui || !ui.imgEl) return;

        // Instantly show this candle as lit
        ui.imgEl.src = 'assets/images/candle_loop.gif';
        stateMap.set(wrap, 'on');
        setAutoTimer(wrap);
      });
    };

  </script>

    <!-- Supabase module: connection + write on light + realtime logging -->
  <script type="module">
    import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

    const SUPABASE_URL = 'https://hclnnnaqyjmgeuavfbry.supabase.co';
    const SUPABASE_ANON_KEY =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhjbG5ubmFxeWptZ2V1YXZmYnJ5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ0MjkzNjgsImV4cCI6MjA4MDAwNTM2OH0.mkCXmoD0Uvg6qSImrA7kS6tBXWtRHX3lPACg31kcpuI';

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // -----------------------------------------------------------
// Whispers: write a whisper row
// -----------------------------------------------------------
window.writeWhisper = async function (candleIndex, textRaw) {
  try {
    const raw = (textRaw || '').trim();
    if (!raw) return;

    // For now: traces only for the public field
    // (simple placeholder trace ‚Äî we'll improve later)
    const trace = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';

        // NEW: remember what THIS tab just submitted so we can suppress trace locally
    window.__lastLocalWhisper = {
      candle_id: `candle_${String(candleIndex).padStart(2, '0')}`,
      text_raw: raw,
      at: Date.now()
    };


    const { error } = await supabase
      .from('whispers')
      .insert({
        candle_id: `candle_${String(candleIndex).padStart(2, '0')}`,
        text_raw: raw,
        trace_public: trace
      });

    if (error) {
      console.error('‚ùå Whisper insert failed:', error.message);
    } else {
      console.log('‚úÖ Whisper inserted');
    }
  } catch (err) {
    console.error('‚ùå Whisper insert exception:', err);
  }
};

    // -----------------------------------------------------------
    // Write / update a candle row when we light it locally
    // -----------------------------------------------------------
    window.writeCandleState = async function (index, litSeconds = 60) {
      const now = new Date();
      const extinguishAt = new Date(now.getTime() + litSeconds * 1000);

      const { error } = await supabase
        .from('candles')
        .upsert({
          candle_index: index,
          is_lit: true,
          lit_at: now.toISOString(),
          extinguish_at: extinguishAt.toISOString()
        });

      if (error) {
        console.error('‚ùå Supabase write failed:', error.message);
      } else {
        console.log(`üî• Wrote candle ${index} to Supabase`);
      }
    };

    // -----------------------------------------------------------
    // Tiny connection test
    // -----------------------------------------------------------
    async function testConnection() {
      try {
        const { data, error } = await supabase
          .from('candles')
          .select('*')
          .limit(1);

        if (error) throw error;
        console.log('‚úÖ Supabase connection OK. Sample data:', data);
      } catch (err) {
        console.error('‚ùå Supabase test failed:', err.message);
      }
    }

    // -----------------------------------------------------------
    // Read all currently lit candles from Supabase
    // (for now we just log them)
    // -----------------------------------------------------------
    async function loadLitCandles() {
      const { data, error } = await supabase
        .from('candles')
        .select('*')
        .gte('extinguish_at', new Date().toISOString());

      if (error) {
        console.error('‚ùå Failed loading lit candles:', error.message);
        return [];
      }

      console.log('üïØÔ∏è Loaded lit candles:', data);
      return data;
    }

   
// -----------------------------------------------------------
// Realtime subscription: listen for whisper inserts
// (author tab suppresses its own trace)
// -----------------------------------------------------------
function listenForWhisperChanges() {
  supabase
    .channel('whispers-realtime')
    .on(
      'postgres_changes',
      { event: 'INSERT', schema: 'public', table: 'whispers' },
      (payload) => {
        console.log('ü´ß Whisper realtime event:', payload);
        console.log('ü´ß Whisper row:', payload.new);

        const row = payload.new;

        // Suppress trace in the tab that authored this whisper
        const last = window.__lastLocalWhisper;
        const isLocal =
          last &&
          row &&
          row.candle_id === last.candle_id &&
          row.text_raw === last.text_raw &&
          (Date.now() - last.at) < 10000; // 10s safety window

        if (!isLocal && window.renderWhisperTraceNearCandle) {
          window.renderWhisperTraceNearCandle(row);
        }
      }
    )
    .subscribe((status) => {
      console.log('ü´ß Whisper realtime status:', status);
    });
}

// -----------------------------------------------------------
// Realtime subscription: light candles when other users light them
// -----------------------------------------------------------
function listenForCandleChanges() {
  supabase
    .channel('candles-realtime')
    .on(
      'postgres_changes',
      { event: 'INSERT', schema: 'public', table: 'candles' },
      (payload) => {
        console.log('üîî Realtime change from Supabase:', payload);
        const row = payload.new;

        if (window.applyBackendLitCandles && row) {
          window.applyBackendLitCandles([row]);
        }
      }
    )
    .subscribe((status) => {
      console.log('üîå Realtime status:', status);
    });
}


    // Kick everything off
    testConnection();
    loadLitCandles();
    listenForCandleChanges();
    listenForTraceChanges();
    listenForWhisperChanges();
    
    // -----------------------------------------------------------
// Realtime subscription: listen for public trace inserts
// (for now we just log them)
// -----------------------------------------------------------
function listenForTraceChanges() {
  const channel = supabase
    .channel('whisper-traces-realtime')
    .on(
      'postgres_changes',
      {
        event: 'INSERT',
        schema: 'public',
        table: 'whisper_traces'
      },
      (payload) => {
        console.log('ü´ß Trace realtime event:', payload);
        console.log('ü´ß Trace row:', payload.new);
      }
    )
    .subscribe((status) => {
      console.log('ü´ß Trace realtime status:', status);
    });
}

  </script>
</body>
</html>
